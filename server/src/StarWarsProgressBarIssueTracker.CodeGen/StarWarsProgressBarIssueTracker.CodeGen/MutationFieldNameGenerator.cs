using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using StarWarsProgressBarIssueTracker.CodeGen.Models;

namespace StarWarsProgressBarIssueTracker.CodeGen;

[Generator]
public sealed class MutationFieldNameGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<MutationFieldNameDataModel?> provider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                $"{typeof(MutationFieldNameAttribute).Namespace}.{nameof(MutationFieldNameAttribute)}",
                static (node, _) => node is MethodDeclarationSyntax,
                static (ctx, _) => GetMethodDeclarationForGen(ctx)
            )
            .Where(static m => m is not null);

        context.RegisterSourceOutput(provider, (sourceContext, data) => GenerateCode(sourceContext, data!));
    }

    private static MutationFieldNameDataModel? GetMethodDeclarationForGen(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not IMethodSymbol methodSymbol)
        {
            return null;
        }

        if (methodSymbol.ContainingType.IsAbstract)
        {
            return null;
        }

        if (methodSymbol.IsStatic)
        {
            return null;
        }

        if (methodSymbol.DeclaredAccessibility != Accessibility.Public)
        {
            return null;
        }

        return new MutationFieldNameDataModel
        {
            MethodName = methodSymbol.Name,
            FullyQualifiedTypeName = methodSymbol.ContainingType.ToDisplayString(new SymbolDisplayFormat(
                SymbolDisplayGlobalNamespaceStyle.Omitted,
                SymbolDisplayTypeQualificationStyle.NameOnly,
                SymbolDisplayGenericsOptions.IncludeTypeParameters,
                SymbolDisplayMemberOptions.IncludeContainingType,
                SymbolDisplayDelegateStyle.NameOnly,
                SymbolDisplayExtensionMethodStyle.Default,
                SymbolDisplayParameterOptions.IncludeType,
                SymbolDisplayPropertyStyle.NameOnly,
                SymbolDisplayLocalOptions.IncludeType
            )),
            Namespace = methodSymbol.ContainingNamespace.ToDisplayString(),
            MinimalTypeName = methodSymbol.ContainingType.Name,
            FieldName = context.Attributes[0].ConstructorArguments[0].Value?.ToString() ?? string.Empty,
            MethodReturnType = methodSymbol.ReturnType.ToDisplayString(),
            MethodParameters = methodSymbol.Parameters.Select(p => p.ToDisplayString()).ToImmutableArray(),
        };
    }

    private void GenerateCode(SourceProductionContext context, MutationFieldNameDataModel mutationFieldNameDataModel)
    {
        // For each method new file, partial class and partial method
        SourceCodeWriter codeGenerator = new();
        codeGenerator.WriteLine("// <auto-generated />");
        codeGenerator.WriteLine("#nullable enable");
        codeGenerator.WriteLine("using HotChocolate.Types;");
        codeGenerator.WriteLine();
        codeGenerator.WriteLine($"namespace {mutationFieldNameDataModel.Namespace};");
        codeGenerator.WriteLine();
        codeGenerator.WriteLine($"public partial class {mutationFieldNameDataModel.FullyQualifiedTypeName}");
        codeGenerator.WriteLine("{");
        codeGenerator.WriteLine($"[UseMutationConvention(PayloadFieldName = \"{mutationFieldNameDataModel.FieldName.ToLower()}\")]");
        codeGenerator.WriteLine($"public partial {mutationFieldNameDataModel.MethodReturnType} {mutationFieldNameDataModel.MethodName}({string.Join(", ", mutationFieldNameDataModel.MethodParameters)});");
        codeGenerator.WriteLine("}");

        context.AddSource($"{mutationFieldNameDataModel.MinimalTypeName}.{mutationFieldNameDataModel.MethodName}.g.cs", SourceText.From(codeGenerator.ToString(), Encoding.UTF8));
    }
}
