using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using StarWarsProgressBarIssueTracker.CodeGen.GraphQL.Models;

namespace StarWarsProgressBarIssueTracker.CodeGen.GraphQL;

[Generator]
public sealed class MutationFieldNameGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        IncrementalValuesProvider<MutationFieldNameDataModel?> provider = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                $"{typeof(MutationFieldNameAttribute).Namespace}.{nameof(MutationFieldNameAttribute)}",
                static (node, _) => node is MethodDeclarationSyntax,
                static (ctx, _) => GetMethodDeclarationForGen(ctx)
            )
            .Where(static m => m is not null);

        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (sourceContext, data) => GenerateCode(sourceContext, data.Right!));
    }

    private static MutationFieldNameDataModel? GetMethodDeclarationForGen(GeneratorAttributeSyntaxContext context)
    {
        if (context.TargetSymbol is not IMethodSymbol methodSymbol)
        {
            return null;
        }

        if (methodSymbol.ContainingType.IsAbstract)
        {
            return null;
        }

        if (methodSymbol.IsStatic)
        {
            return null;
        }

        if (methodSymbol.DeclaredAccessibility != Accessibility.Public)
        {
            return null;
        }

        string fieldName =
            context.Attributes
                .FirstOrDefault(attr => attr.AttributeClass?.ToDisplayString() == nameof(MutationFieldNameAttribute))
                ?.ConstructorArguments[0].Value?.ToString() ?? string.Empty;

        return new MutationFieldNameDataModel
        {
            MethodName = methodSymbol.Name,
            FullyQualifiedTypeName = methodSymbol.ContainingType.ToDisplayString(new SymbolDisplayFormat(
                SymbolDisplayGlobalNamespaceStyle.Omitted,
                SymbolDisplayTypeQualificationStyle.NameOnly,
                SymbolDisplayGenericsOptions.IncludeTypeParameters,
                SymbolDisplayMemberOptions.IncludeContainingType,
                SymbolDisplayDelegateStyle.NameOnly,
                SymbolDisplayExtensionMethodStyle.Default,
                SymbolDisplayParameterOptions.IncludeType,
                SymbolDisplayPropertyStyle.NameOnly,
                SymbolDisplayLocalOptions.IncludeType
            )),
            Namespace = methodSymbol.ContainingNamespace.ToDisplayString(),
            MinimalTypeName = methodSymbol.ContainingType.Name,
            FieldName = fieldName,
            MethodReturnType = methodSymbol.ReturnType.ToDisplayString(),
            MethodParameters = methodSymbol.Parameters.Select(p => p.ToDisplayString()).ToImmutableArray(),
        };
    }

    private void GenerateCode(SourceProductionContext context, ImmutableArray<MutationFieldNameDataModel> mutationFieldNameDataModel)
    {
        IEnumerable<IGrouping<string, MutationFieldNameDataModel>> groupedMethodsByClass =
            mutationFieldNameDataModel.GroupBy(m => m.FullyQualifiedTypeName);

        foreach (IGrouping<string, MutationFieldNameDataModel> group in groupedMethodsByClass)
        {
            MutationFieldNameDataModel mutationFieldDataModel = group.First();
            SourceCodeWriter codeGenerator = new();
            codeGenerator.WriteLine("// <auto-generated />");
            codeGenerator.WriteLine("#nullable enable");
            codeGenerator.WriteLine("using HotChocolate.Types;");
            codeGenerator.WriteLine();
            codeGenerator.WriteLine($"namespace {mutationFieldDataModel.Namespace};");
            codeGenerator.WriteLine();
            codeGenerator.WriteLine($"public partial class {mutationFieldDataModel.FullyQualifiedTypeName}");
            codeGenerator.WriteLine("{");

            foreach (MutationFieldNameDataModel mutationField in group)
            {
                codeGenerator.WriteLine(
                    $"[UseMutationConvention(PayloadFieldName = \"{mutationField.FieldName.ToLower()}\")]");
                codeGenerator.WriteLine(
                    $"public partial {mutationField.MethodReturnType} {mutationField.MethodName}({string.Join(", ", mutationField.MethodParameters)});");
                codeGenerator.WriteLine();
            }

            codeGenerator.WriteLine("}");

            context.AddSource($"{mutationFieldDataModel.MinimalTypeName}.g.cs",
                SourceText.From(codeGenerator.ToString(), Encoding.UTF8));
        }
    }
}
